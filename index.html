<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">

	<title>Talk | FullStack London, 2017 | Node.js Add-ons for High Performance Numeric Computing</title>

	<meta name="description" content="Node.js add-ons allow native code written in C and C++ to be run from the Node.js JavaScript runtime. In this talk, Athan will discuss how to utilize native add-ons for high performance numeric computing and machine learning in server-side applications. He will first provide an overview of add-ons and their associated toolchain. Next, he will provide a step-by-step example which involves compiling basic linear algebra subroutines (BLAS), a suite of libraries which are part of the core foundation of most modern numeric computing environments, as native add-ons. While Node.js add-ons are oriented toward C and C++, he will show how to extend compilation support to Fortran libraries in order to maximize computational performance. Throughout this talk, Athan will offer lessons learned, tips and tricks, and other insights gained while writing add-ons to help you maximize Node.js for your server-side applications and to demonstrate why Node.js is an excellent environment for high performance numeric computing and machine learning.">
	<meta name="author" content="Athan Reines">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<!-- Icons -->
	<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
	<link rel="manifest" href="manifest.json">
	<link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
	<meta name="theme-color" content="#ffffff">

	<!-- Facebook Open Graph -->
	<meta property="og:type" content="website">
	<meta property="og:site_name" content="stdlib">
	<meta property="og:url" content="http://stdlib.io/">
	<meta property="og:title" content="A standard library for JavaScript and Node.js.">
	<meta property="og:description" content="stdlib is a standard library for JavaScript and Node.js, with an emphasis on numeric computing.">
	<meta property="og:locale" content="en_US">
	<meta property="og:image" content="">

	<!-- Twitter -->
	<meta name="twitter:card" content="A standard library for JavaScript and Node.js.">
	<meta name="twitter:site" content="@stdlibjs">
	<meta name="twitter:url" content="http://stdlib.io/">
	<meta name="twitter:title" content="stdlib">
	<meta name="twitter:description" content="stdlib is a standard library for JavaScript and Node.js, with an emphasis on numeric computing.">
	<meta name="twitter:image" content="">

	<!-- Stylesheets -->
	<link rel="stylesheet" href="css/grid.css">
	<link rel="stylesheet" href="css/font-awesome.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/white.css">
	<link rel="stylesheet" href="css/style.css">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="css/code/zenburn.css">

	<!-- Printing and PDF exports -->
	<script src="js/lib/reveal/pdf.js"></script>

	<!--[if lt IE 9]>
	<script src="js/lib/reveal/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

	<header>
		<a href="https://github.com/stdlib-js/stdlib"><img src="img/long_logo_white.svg" alt="stdlib"></a>
	</header>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section id="splash" class="center" data-transition="fade-out">
				<div>
					<a href="https://github.com/stdlib-js/stdlib"><img src="img/long_logo_white.svg" alt="stdlib" class="undecorated" height="35%" width="35%"></a>
				</div>
				<div>
					<small><a href="https://github.com/kgryte"><i class="fa fa-github"></i> Athan Reines</a> | <a href="https://twitter.com/kgryte"><i class="fa fa-twitter"></i> @kgryte</a> | <a href="https://twitter.com/stdlibjs"><i class="fa fa-twitter"></i> @stdlibjs</a></small>
				</div>
				<!-- <div>
					<a href="https://github.com/stdlib-js/stdlib"><img src="img/hex_sticker_black.svg" alt="stdlib" class="undecorated"></a>
				</div> -->
				<aside class="notes">

				</aside>
			</section>

			<section id="title-slide" class="center">
				<h1>Node.js Add-ons for High Performance Numeric Computing</h1>

				<aside class="notes">

				</aside>
			</section>

			<section class="center">
				<h2 class="no-text-transform">Survey</h2>

				<aside class="notes">
					<ul>
						<li>Who here has heard of Node.js native add-ons?</li>
						<li>Who here has written a native add-on?</li>
						<li>Who here has used a Node.js native add-on for numeric computing?</li>
					</ul>
				</aside>
			</section>

			<section class="center">
				<h2 class="no-text-transform">Overview</h2>

				<div class="row">
					<ul class="column column-3">
						&nbsp;
					</ul>
					<ol class="column column-8">
						<li class="fragment">Intro</li>
						<li class="fragment">Toolchain</li>
						<li class="fragment">Numeric Computing</li>
						<li class="fragment">Basic Example</li>
						<li class="fragment">BLAS</li>
						<li class="fragment">Performance</li>
						<li class="fragment">Challenges</li>
						<li class="fragment">N-API</li>
						<li class="fragment">Conclusions</li>
					</ol>
				</div>

				<aside class="notes">
					<p>
						This talk will be technical, but we will try to avoid going too far into the weeds. :)
					</p>
					<ul>
   						<li>
   							First, I will provide an overview of Node.js native add-ons.
   						</li>
   						<li>
   							Next, I will introduce the current toolchain for authoring add-ons.
   						</li>
   						<li>
   							Then, I will touch on why native add-ons are important for numeric computing.
   						</li>
   						<li>
  							I'll follow by showing a basic native add-on example.
  						</li>
   						<li>
   							After the basic example, I'll move on to a more complex example where we need to write an add-on which links a BLAS library written in Fortran to the the JavaScript runtime.
   						</li>
   						<li>
   							Next, I'll will show performance comparisons.
   						</li>
   						<li>
   							Then, I'll discuss some of the hurdles we have faced writing native add-ons for numeric computing and how we have worked to address them.
   						</li>
   						<li>
   							Before concluding, I will mention N-API, an application binary interface, or ABI, which aims to provide a stable abstraction layer over JavaScript engines.
   						</li>
   						<li>
   							And finally, I will offer some conclusions and additional resources you can use to get started using Node.js native add-ons for high-performance numeric computing.
   						</li>
   					</ul>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section class="center">
				<h2 class="no-text-transform">Native Add-ons</h2>

				<aside class="notes">
					<p>
						Without further ado...intro.
					</p>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<p>
					Interface between JS running in Node.js and C/C++ libraries
				</p>

				<aside class="notes">
					<p>
						A Node.js native add-on provides an interface between JavaScript running in Node.js and, primarily, C/C++ libraries.
					</p>
					<p>
						From the perspective of Node.js applications, an add-on is just another module which an application can <code>require</code>.
					</p>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<h2 class="no-text-transform">APIs</h2>
				<div class="row">
					<ul class="column column-3">
						&nbsp;
					</ul>
					<ul class="column column-8">
						<li class="fragment">V8</li>
						<li class="fragment">libuv</li>
						<li class="fragment">Internal Libraries</li>
						<li class="fragment">Dependencies</li>
					</ul>
				</div>

				<aside class="notes">
					<p>
						Add-ons have access to four components of the Node.js runtime:
					</p>
     				<ul>
     					<li>
     						V8: C++ library which runs JavaScript. Allows creating objects, calling functions, etc.
     					</li>
     					<li>
     						libuv: C library which implements the Node.js event loop, worker threads, and async behavior. Allows interacting with the filesystem, sockets, timers, and system events.
     					</li>
     					<li>
     						Internal Node.js libraries: Node.js exposed C++ APIs.
     					</li>
     					<li>
     						Node.js own dependencies: statically linked libraries; e.g., OpenSSL.
     					</li>
     				</ul>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<h2 class="no-text-transform">Examples</h2>
				<div class="row">
					<ul class="column column-3">
						&nbsp;
					</ul>
					<ul class="column column-8">
						<li class="fragment"><a href="https://github.com/Level/leveldown">leveldown</a></li>
						<li class="fragment"><a href="https://github.com/nickdesaulniers/node-nanomsg">node-nanomsg</a></li>
						<li class="fragment"><a href="https://github.com/Automattic/node-canvas">node-canvas</a></li>
						<li class="fragment"><a href="https://github.com/mapbox/node-sqlite3">node-sqlite3</a></li>
						<li class="fragment"><a href="https://github.com/stdlib-js/stdlib">stdlib</a></li>
					</ul>
				</div>

				<aside class="notes">
					<p>
						Native add-on examples...
					</p>
					<ul>
						<li>
							<a href="https://github.com/Level/leveldown">leveldown</a>: pure C++ Node.js LevelDB binding
						</li>
    					<li>
    						<a href="https://github.com/nickdesaulniers/node-nanomsg">node-nanomsg</a>: Node.js binding for nanomsg</a>
    					</li>
    					<li>
    						<a href="https://github.com/Automattic/node-canvas">node-canvas</a>: Cairo backed canvas implementation
    					</li>
     					<li>
     						<a href="https://github.com/mapbox/node-sqlite3">node-sqlite3</a>: Node.js bindings for SQLite3
     					</li>
     					<li>
     						<a href="https://github.com/stdlib-js/stdlib">stdlib</a>: contains Node.js bindings to high-performance BLAS libraries
     					</li>
     				</ul>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<h2 class="no-text-transform">Why?</h2>

				<aside class="notes">
					Why would you choose a native add-on over plain JavaScript?
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<div class="row">
					<ul class="column column-3">
						&nbsp;
					</ul>
					<ul class="column column-8">
						<li class="fragment">Leverage existing codebases</li>
						<li class="fragment">Access lower-level APIs</li>
						<li class="fragment">Non-JavaScript features</li>
						<li class="fragment">Performance</li>
					</ul>
				</div>

				<aside class="notes">
					<p>
						Four primary reasons...
					</p>
					<p>
						One reason is that you want to link to existing C/C++ libraries. This allows you to avoid having to port and re-implement functionality in JavaScript, which, for larger libraries, can be a substantial undertaking.
					</p>
					<p>
     					Next, you may want to access lower-level APIs, such as worker threads.
     				</p>
     				<p>
     					Third, you may need language features not available in JavaScript, such as 64-bit integers or SIMD.
     				<p>
     					Last, you need a performance boost, including leveraging hardware optimization.
     				</p>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					<p>
						So now that you have decided to use native add-ons, how do you go about doing so?
					</p>
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<h2 class="no-text-transform">Toolchain</h2>

				<aside class="notes">
					And with that, we need to talk about the native add-on toolchain.
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section class="center" data-transition="slide-in slide-out" data-transition-speed="default">
				<h2 class="no-text-transform">node-gyp</h2>

				<aside class="notes">
					<p>
						We begin with node-gyp, which is a cross-platform command-line tool written in Node.js for compiling native add-ons for Node.js.
					</p>
					<p>
						node-gyp bundles GYP and automatically downloads necessary development files and headers for target Node.js versions.
					</p>
				</aside>
			</section>

			<section class="center" data-transition="slide-in slide-out" data-transition-speed="default">
				<h2 class="no-text-transform">GYP</h2>

				<aside class="notes">
					<p>
     					GYP, generate your project, is a meta-build system, which builds other build systems, depending on the target platform.
     				</p>
     				<p>
     					The aim of GYP is to replicate, as closely as possible, the native build setup of a target platform IDE. So, for example, on MacOS, that means generating XCode projects. Or on Windows, Visual Studio projects.
     				</p>
     				<p>
						And once GYP generates the build system, we can compile our add-on.
     				</p>
     				<p>
     					Now, for a bit of background and to introduce a caveat in using GYP, GYP was developed in 2009, when Chrome was Windows-only. When they wanted to build for Mac, they did not want to maintain two separate build systems. So they created GYP to centralize build configuration and automatically generate native projects.
     				</p>
    				<p>
    					As time moved on, so did the Chrome team. GYP has now been deprecated in favor of GN which targets Ninja. Despite being "abandonware", Node.js seems wedded to it for the foreseeable future.
    				</p>
    				<p>
    					As an aside, this is part of the risk of hitching a ride on corporate projects, where they are not incentivized to maintain and devote resources to something they no longer use internally.
    				</p>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					Moving along, developing native add-ons has, historically, not been a smooth process.
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<h2 class="no-text-transform">Challenges</h2>

				<div class="row">
					<ul class="column column-3">
						&nbsp;
					</ul>
					<ul class="column column-8">
						<li class="fragment">V8</li>
						<li class="fragment">NAN</li>
						<li class="fragment">GYP</li>
						<li class="fragment">Engine Bias</li>
					</ul>
				</div>

				<aside class="notes">
					<p>
						Here have been some of the challenges.
					</p>
					<p>
						The foremost challenge has been handling breaking changes in V8.
					</p>
    				<p>
    					Each Node.js major release entailed a new V8. In the past, the V8 team was not concerned about backward compatibility and would often introduce sweeping changes, removing, replacing, and adding interfaces and functionality. These changes would force add-on authors to effectively rewrite their packages, publish a semver major, and make providing backward compatibility extremely difficult.
    				</p>
					<p>
     					To alleviate some of the "pain" of native add-ons, members of the Node.js community created a package NAN, which stands for Native Abstractions for Node.js.
     				</p>
     				<p>
     					NAN attempts to provide a stable abstraction layer that native add-on authors can target. Internally, NAN handles the complex logic required to maintain functionality from one V8 version to the next.
     				</p>
     				<p>
     					And while NAN has been beneficial, even it has caused churn due to breaking changes in its API while attempting to smooth the transition from one V8 version to the next.
     				</p>
					<p>
    					Another issue is GYP. GYP was designed with a particular use case in mind: Chrome. It was not designed with Node.js add-ons in mind.
    				</p>
    				<p>
    					Further, GYP documentation is either poor or incomplete, presenting significant challenges whenever you want to do something beyond simple "hello world" type examples.
    				</p>
    				<p>
    					To make up for a lack of documentation, you end up scouring the Internet looking for other projects using GYP and seeing how those projects handle special configurations. And in particular, anytime you want to break out of the confines of C/C++, say, to compile Fortran or Cuda, good luck.
    				</p>
    				<p>
    					Resources are few and far between.
    				</p>
					<p>
    					A more forward looking concern is that node-gyp is biased toward V8. Meaning the toolchain is not engine neutral. This means compiling Node.js and Node.js native add-ons with alternative engines, such as Chakra, is less straightforward, requiring shims like Chakrashim.
					</p>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					Despite these challenges, native add-ons are highly important for numeric computing.
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<h2 class="no-text-transform">Numeric Computing</h2>

				<aside class="notes">
					<p>
						Native add-ons are important for numeric computing because they allow us to interface with high-performance numeric computing libraries written in C/C++.
					</p>
   					<p>
   						What you find when combing through the implementations of Julia, R, and Python libraries like NumPy and SciPy is that a substantial amount of the functionality they expose relies on providing wrappers for existing numeric computing code bases written in C/C++ and Fortran.
   					</p>
   					<p>
   						For example, for high-performance linear algebra, these platforms wrap BLAS and LAPACK. For fast Fourier transforms, they wrap FFTW. In the particular case of Julia, for BigInt, Julia wraps GMP. For BigFloat, Julia wraps MPFR.
   					</p>
   					<p>
   						Node.js native add-ons allow us to do something similar as these other platforms; namely, expose high-performance numeric computing functionality to Node.js and to JavaScript.
   					</p>
   					<p>
   						This means we can leverage highly optimized libraries which have stood the test of time and do less "reinventing the wheel".
   					</p>
   					<p>
						In short, native add-ons allow us to do in Node.js what other environments used for numeric computing can do.
					</p>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					At this point, we have discussed, at a high-level, what native add-ons are, their toolchain, some challenges, and motivated why they are important for numeric computing. Let's now make things a bit more concrete by walking through a basic example...
				</aside>
			</section>

			<section class="center" data-transition="fade-in slide-out" data-transition-speed="default">
				<h2 class="no-text-transform">Basic Example</h2>

				<aside class="notes">

				</aside>
			</section>

			<section class="center">
				<pre><code class="hljs c" contenteditable>
/* hypot.h */
#ifndef C_HYPOT_H
#define C_HYPOT_H

#ifdef __cplusplus
extern "C" {
#endif

double c_hypot( const double x, const double y );

#ifdef __cplusplus
}
#endif

#endif
				</code></pre>

				<aside class="notes">
					<p>
						We first define a basic header file defining the interface to the function exported to the JavaScript runtime, taking care to guard against name mangling and ensuring similar behavior as might be observed when using a standard C compiler.
					</p>
				</aside>
			</section>

			<section class="center">
				<pre><code class="hljs c" contenteditable>
/* hypot.c */
#include &lt;math.h&gt;
#include "hypot.h"

double c_hypot( const double x, const double y ) {
    double tmp;
    double a;
    double b;
    if ( isnan( x ) || isnan( y ) ) {
        return NAN;
    }
    if ( isinf( x ) || isinf( y ) ) {
        return INFINITY;
    }
    a = x;
    b = y;
    if ( a &lt; 0.0 ) {
        a = -a;
    }
    if ( b &lt; 0.0 ) {
        b = -b;
    }
    if ( a &lt; b ) {
        tmp = b;
        b = a;
        a = tmp;
    }
    if ( a == 0.0 ) {
        return 0.0;
    }
    b /= a;
    return a * sqrt( 1.0 + (b*b) );
}
				</code></pre>

				<aside class="notes">
					<p>
						Next, we write our implementation. In this example, we are computing the hypotenuse, guarding against overflow and underflow.
					</p>
					<p>
						This is a standard C implementation which imports the standard math library and includes a function which accepts two arguments, x and y, and returns a numeric result.
					</p>
				</aside>
			</section>

			<section class="center">
				<aside class="notes">
					(next slide)
				</aside>
			</section>

			<section class="center" data-transition="fade-in fade-out" data-transition-speed="default">
				<h2 class="no-text-transform">Thank you!</h2>

				<aside class="notes">

				</aside>
			</section>

			<section class="center">
				<div>
					<a href="https://github.com/stdlib-js/stdlib"><img src="img/hex_sticker_black.svg" alt="stdlib" class="undecorated"></a>
				</div>

				<p>
					<small><a href="https://github.com/stdlib-js/stdlib"><i class="fa fa-github"></i> https://github.com/stdlib-js/stdlib</a></small>
					<br>
					<small><a href="https://www.patreon.com/athan"><i class="fa fa-bitcoin"></i> https://www.patreon.com/athan</a></small>
				</p>

				<aside class="notes">

				</aside>
			</section>

			<section>
				<!-- Add blank slide to separate main presentation from appendix -->
				<aside class="notes">
					Intentionally left blank.
				</aside>
			</section>

			<section class="center">
				<h2>Appendix</h2>
			</section>

			<section class="center">
				<!-- Intentionally many lines -->
				<pre><code class="hljs javascript" contenteditable>




















				</code></pre>
				<aside class="notes">
					Slide for code editing.
				</aside>
			</section>

			<!-- <section class="center">
				<h2>Heading</h2>
			</section> -->

			<section class="center">
				<h2>The End</h2>
			</section>

		</div>

	</div>

	<footer>
		<a href="https://github.com/kgryte"><i class="fa fa-github"></i> Athan Reines</a> | <a href="https://twitter.com/kgryte"><i class="fa fa-twitter"></i> @kgryte</a> | <a href="https://twitter.com/stdlibjs"><i class="fa fa-twitter"></i> @stdlibjs</a>
	</footer>

	<script src="js/lib/reveal/head.min.js"></script>
	<script src="js/lib/reveal/reveal.js"></script>
	<script src="js/lib/reveal/init.js"></script>
	<script src="js/script.js"></script>
</body>
</html>
